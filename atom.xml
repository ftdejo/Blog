<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈六的博客</title>
  <subtitle>memo for code or game.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ftdejo.github.io/"/>
  <updated>2017-04-24T03:33:36.753Z</updated>
  <id>https://ftdejo.github.io/</id>
  
  <author>
    <name>陈六</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java intern()相关</title>
    <link href="https://ftdejo.github.io/2017/02/28/java-intern-%E7%9B%B8%E5%85%B3/"/>
    <id>https://ftdejo.github.io/2017/02/28/java-intern-相关/</id>
    <published>2017-02-28T08:21:28.000Z</published>
    <updated>2017-04-24T03:33:36.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-String中intern-方法相关"><a href="#java-String中intern-方法相关" class="headerlink" title="java String中intern()方法相关"></a>java String中intern()方法相关</h2><blockquote>
<p>intern 这个方法返回的是返回字符串对象的规范化表示形式，当调用 intern 方法时，如果常量池已经包含一个等于此String 对象的字符串(该对象由equals(Object) 方法确定)，则返回池中的字符串。否则，将此String对象添加到池中，并且返回此 String 对象的引用。</p>
</blockquote>
<p><del>Talk is cheap show me the code</del></p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str1= &quot;aa&quot;;</div><div class="line">String str2 = new String(&quot;bb&quot;);</div><div class="line">System.out.println(&quot;******&quot;);</div><div class="line">System.out.println(str1.intern() == str1); //#1</div><div class="line">System.out.println(str2.intern() == str2); //#2</div></pre></td></tr></table></figure>
<blockquote>
<p>通过字面量赋值创建字符串时，会优先在常量池中查找是否已经存在相同的字符串，倘若已经存在，栈中的引用直接指向该字符串；倘若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。而通过new的方式创建字符串时，就直接在堆中生成一个字符串的对象。</p>
</blockquote>
<p>#1：因为str1指向的是常量池中的引用，调用intern()方法返回同一个引用，所以返回true。</p>
<p>#2：str2创建的字符串实例在java堆上，调用intern()方法必然不是同一个引用，所以返回false</p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">String baseStr = &quot;ccdd&quot;;</div><div class="line">final String baseFinalStr = &quot;ccdd&quot;;</div><div class="line"> </div><div class="line">String str1 = &quot;ccdd&quot;;</div><div class="line">String str2 = &quot;cc&quot;+&quot;dd&quot;;</div><div class="line">String str3 = baseStr + &quot;dd&quot;;</div><div class="line">String str4 = baseFinalStr+&quot;dd&quot;;</div><div class="line"> </div><div class="line">System.out.println(str1 == str2);//#3</div><div class="line">System.out.println(str1 == str3);//#4</div><div class="line">System.out.println(str1 == str4);//#5</div></pre></td></tr></table></figure>
<p>#3：常量字符串的”+”操作，编译阶段直接作为一个字符串处理，所以返回true</p>
<p>#4：字符串引用的”+”操作，其实是StringBuilder.append()操作，而由StringBuilder创建的字符串实例在Java堆上，所以返回false</p>
<p>#5：对于final修饰符，编译期直接进行了常量替换，而对于非final字段则是在运行期进行赋值处理的，所以str4相当于常量字符串，返回true</p>
<h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str1=new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString();</div><div class="line">String str2=new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</div><div class="line"></div><div class="line">System.out.println(str1.intern()==str1);  // #6</div><div class="line">System.out.println(str2.intern()==str2);  // #7</div></pre></td></tr></table></figure>
<p><strong>对于这段代码，在 JDK 1.6 和 JDK 1.7中的运行结果不同。<br>这段代码在JKD1.6中运行，会得到2个false。在JDK1.7中的运行结果却是true和false！</strong></p>
<blockquote>
<p>这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7后的intern方法在实现上发生了比较大的改变，JDK 1.7后(以及部分其他虚拟机，例如JRockit)，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中记录首次出现的实例引用。</p>
</blockquote>
<p>#6 常量池中没有”计算机软件”这个字符串，所以会在常量池中生成一个对堆中的”计算机软件”的引用，而在进行字面量赋值的时候，常量池中已经存在，所以直接返回该引用即可，因此str1和str2都指向堆中的字符串，返回true</p>
<p>#7 常量池中存在”java”字符串..至于为什么存在，不要在意这些细节..，所以str2.intern()会返回常量池中引用，返回false</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java-String中intern-方法相关&quot;&gt;&lt;a href=&quot;#java-String中intern-方法相关&quot; class=&quot;headerlink&quot; title=&quot;java String中intern()方法相关&quot;&gt;&lt;/a&gt;java String中inte
    
    </summary>
    
    
      <category term="Java" scheme="https://ftdejo.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
