<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈六的博客</title>
  <subtitle>memo for code or game.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ftdejo.github.io/"/>
  <updated>2018-03-21T12:15:29.906Z</updated>
  <id>https://ftdejo.github.io/</id>
  
  <author>
    <name>陈六</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++虚函数相关</title>
    <link href="https://ftdejo.github.io/2018/02/21/c-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/"/>
    <id>https://ftdejo.github.io/2018/02/21/c-虚函数相关/</id>
    <published>2018-02-21T04:33:56.000Z</published>
    <updated>2018-03-21T12:15:29.906Z</updated>
    
    <content type="html"><![CDATA[<p>   ​c++虚表指针及虚表是实现多态的关键，因此有必要了解下实现方法。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h3><p>(本文运行环境为VS2017 编译器MSVC)</p>
<p>在Visual Studio里，可以利用reportAllClassLayout查看内存。具体实现如下：</p>
<p><img src="pic2.png" alt=""><br><img src="pic1.png" alt=""></p>
<h3 id="普通类"><a href="#普通类" class="headerlink" title="普通类:"></a>普通类:</h3><p>接下来就可以愉快的敲代码了，首先定义一个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">int</span> b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后编译，可以看到有如下的排布：</p>
<p><img src="pic3.png" alt=""></p>
<p>因为这里要去除内存对齐的因素，所以我都用了int型，从这里可以看到普通类的排布方式，成员变量依据声明的顺序进行排列（类内偏移为0开始），成员函数不占内存空间。</p>
<h3 id="继承类"><a href="#继承类" class="headerlink" title="继承类:"></a>继承类:</h3><p>然后定义一个继承类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> DerivedClass: <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DerivedFunction</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后编译下：</p>
<p><img src="pic4.png" alt=""></p>
<p>可以看到子类继承了父类的成员变量，在内存排布上，先是排布了父类的成员变量，接着排布子类的成员变量，同样，成员函数不占字节。</p>
<h3 id="虚函数-无覆盖-一般继承"><a href="#虚函数-无覆盖-一般继承" class="headerlink" title="虚函数(无覆盖 一般继承):"></a>虚函数(无覆盖 一般继承):</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">VirtualFunction</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> DerivedClass : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">VirtualFunction1</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里我加上了一个虚函数，先看下基类内存分布：</p>
<p><img src="pic5.png" alt=""></p>
<p>这个内存结构图分成了两个部分，上面是内存分布，下面是虚表，我们逐个看。MSVC是把虚表指针放在了内存的开始处（0地址偏移），然后再是成员变量；下面生成了虚表，紧跟在&amp;Base_meta后面的0表示，这张虚表对应的虚指针在内存中的分布，下面列出了虚函数，左侧的0是这个虚函数的序号，这里只有一个虚函数，所以只有一项，如果有多个虚函数，会有序号为1，为2的虚函数列出来。注意这里的只是虚表里面增加，虚函数指针只有一个。</p>
<p>然后我给子类加上了个额外的虚函数，但是没有覆盖父类的。再来看子类内存排布：</p>
<p><img src="pic6.png" alt=""></p>
<p>上半部是内存分布，可以看到，虚表指针被继承了，且仍位于内存排布的起始处，下面是父类的成员变量a和b，最后是子类的成员变量c，注意虚表指针只有一个，子类并没有再生成虚表指针了。从以上内存分布，可以看出：</p>
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面。</li>
</ol>
<h3 id="虚函数-覆盖-一般继承"><a href="#虚函数-覆盖-一般继承" class="headerlink" title="虚函数(覆盖 一般继承):"></a>虚函数(覆盖 一般继承):</h3><p>如果不覆盖，那么我们多态就无从谈起，于是这里我修改了下子类代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">VirtualFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">VirtualFunction2</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> DerivedClass : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">VirtualFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">VirtualFunction3</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>重新编译程序，可以看到以下内存分布:</p>
<p><img src="pic7.png" alt=""></p>
<p>可以发现，Base::VirtualFunction在虚表中不见了，那么总结出：</p>
<ol>
<li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态!"></a>多态!</h3><p>那么编译器是如何利用虚表指针与虚表来实现多态的呢？是这样的，当创建一个含有虚函数的父类的对象时，编译器在对象构造时将虚表指针指向父类的虚函数；同样，当创建子类的对象时，编译器在构造函数里将虚表指针（子类只有一个虚表指针，它来自父类）指向子类的虚表（这个虚表里面的虚函数入口地址是子类的）。</p>
<p>所以，对于这样一段代码<code>Base *p = new Derived()</code>:</p>
<p>生成的是子类的对象，在构造时，子类对象的虚指针指向的是子类的虚表，接着由<code>Derived*</code>到<code>Base*</code>的转换并没有改变虚表指针，所以这时候<code>p-&gt;VirtualFunction</code>， 由p所指的内存中的虚函数表的<code>VirtualFunction()</code>的位置已经被<code>Derive::VirtualFunction()</code>函数地址所取代，于是在实际调用发生时，是<code>Derive::VirtualFunction()</code>被调用了。这就实现了多态。</p>
<h3 id="多重继承-无覆盖"><a href="#多重继承-无覆盖" class="headerlink" title="多重继承(无覆盖)"></a>多重继承(无覆盖)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedClass1 : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f1</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedClass2 : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> d;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f2</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedDerivedClass : <span class="keyword">public</span> DerivedClass1, <span class="keyword">public</span> DerivedClass2</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> e;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedDerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f3</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>内存分布图(前三个省略)：</p>
<p><img src="pic8.png" alt=""></p>
<p>下面我们重点看看这个类DerivedDerivedClass，由外向内看，它并列地排布着继承而来的两个父类DerivedClass1与DerivedClass2，还有自身的成员变量e。DerivedClass1包含了它的成员变量c，以及Base，Base有一个0地址偏移的虚表指针，然后是成员变量a和b；DerivedClass2的内存排布类似于DerivedClass1，偏移量为16(即，注意到DerivedClass2里面竟然也有一份Base。</p>
<p>可以看到:</p>
<ol>
<li>每个父类都有自己的虚表</li>
<li>存了2个虚表指针，来指向不同的父类虚表</li>
<li>子类的虚函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<h3 id="多重继承-有覆盖"><a href="#多重继承-有覆盖" class="headerlink" title="多重继承(有覆盖)"></a>多重继承(有覆盖)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">g</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedClass1 : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">g1</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedClass2 : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> d;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">g2</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedDerivedClass : <span class="keyword">public</span> DerivedClass1, <span class="keyword">public</span> DerivedClass2</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> e;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedDerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">g3</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="pic85.png" alt=""></p>
<p><img src="pic9.png" alt=""></p>
<p>我们可以看见，<strong>两个</strong>父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DerivedDerivedClass d;</div><div class="line">DerivedClass1 *b2 = &amp;d;</div><div class="line">DerivedClass2 *b3 = &amp;d;</div><div class="line">b2-&gt;f(); <span class="comment">//DerivedDerivedClass::f()</span></div><div class="line">b3-&gt;f(); <span class="comment">//DerivedDerivedClass::f()</span></div></pre></td></tr></table></figure>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>不知道看官注意到了没，在上文中，我没有写<code>Base b = &amp;d; b-&gt;f();</code></p>
<p>这样的代码为什么出问题，如果是从上文阅读过来，我想这个问题一定难不倒你:)</p>
<p>关键是怎么解决呢？那么可以利用虚继承的概念。</p>
<blockquote>
<p>在虚继承下，对给定虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象。共享的基类子对象称为虚基类。   <em>《c++ primer》</em>                           </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedClass1 : <span class="keyword">public</span> <span class="keyword">virtual</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedClass2 : <span class="keyword">public</span> <span class="keyword">virtual</span> Base</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> d;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DerivedDerivedClass : <span class="keyword">public</span> DerivedClass1, <span class="keyword">public</span> DerivedClass2</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> e;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DerivedDerivedCommonFunction</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>编译上述代码：</p>
<p><img src="v1.png" alt=""></p>
<p>Base没有变化。但是只要我们往下，就会发现很多不同的东西：</p>
<p><img src="v2.png" alt=""></p>
<p>DerivedClass1就已经有变化了，原来是先排虚表指针与Base成员变量，vfptr位于0地址偏移处；但现在有两个虚表指针了，一个是vbptr，另一个是vfptr。vbptr是这个DerivedClass1对应的虚表指针，它指向DerivedClass1的虚表vbtable，另一个vfptr是虚基类表对应的虚指针，它指向vftable。</p>
<p>然后是两张虚表，第一张表是vbptr指向的表，8表示{vbptr}与{vfptr}的偏移；第二张表是vfptr指向的表，-8指明了这张表所对应的虚指针位于内存的偏移量。</p>
<p><img src="v3.png" alt=""><br>DerivedClass2与上图相似，同样会有两个虚指针，分别指向两张虚表（第二张是虚基类表）。</p>
<p><img src="v4.png" alt=""><br>我们来仔细看一下DerivedDerivedClass的内存分布，这里面有三个虚指针了，但base却只有一份。第一张虚表是内含DerivedClass1的，20表示它的虚指针{vbptr}离虚基表指针{vfptr}的距离，第二张虚表是内含DerivedClass2的，12表示它的虚指针{vbptr}离虚基表指针{vfptr}的距离，最后一张表是虚基表，-20指明了它对应的虚指针{vfptr}在内存中的偏移。</p>
<p>虚继承的作用是减少了对基类的重复，代价是增加了虚表指针的负担（更多的虚表指针）。<br>下面总结一下（当基类有虚函数时）：</p>
<ol>
<li><p>每个类都有虚指针和虚表；</p>
</li>
<li><p>如果不是虚继承，那么子类将父类的虚指针继承下来，并指向自身的虚表（发生在对象构造时）。有多少个虚函数，虚表里面的项就会有多少。多重继承时，可能存在多个的基类虚表与虚指针；</p>
</li>
<li><p>如果是虚继承，那么子类会有两份虚指针，一份指向自己的虚表，另一份指向虚基表，多重继承时虚基表与虚基表指针有且只有一份。</p>
</li>
</ol>
<p>Enjoy!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   ​c++虚表指针及虚表是实现多态的关键，因此有必要了解下实现方法。&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://ftdejo.github.io/tags/c/"/>
    
      <category term="MSVC" scheme="https://ftdejo.github.io/tags/MSVC/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode]Insert Interval插入区间</title>
    <link href="https://ftdejo.github.io/2018/01/25/LeetCode-Insert-Interval%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>https://ftdejo.github.io/2018/01/25/LeetCode-Insert-Interval插入区间/</id>
    <published>2018-01-25T09:31:56.000Z</published>
    <updated>2018-01-25T11:08:09.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><blockquote>
<p>leetcode: Problem #57</p>
<p><strong>Insert Interval</strong></p>
<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p><strong>Example 1:</strong><br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p>
<p><strong>Example 2:</strong><br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p>
<p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p>
</blockquote>
<a id="more"></a>
<p>题目大意就是给出一段已经排序好的不重叠区间，然后求解插入新的数据后的区间。</p>
<h3 id="解"><a href="#解" class="headerlink" title="解:"></a>解:</h3><p>由题目得知本来已经有序，所以我们只需要找到和给出数据重合的部分，然后更新相关值即可。</p>
<p><img src="f1.png" alt=""></p>
<p>主要的问题就是寻找左右边界：</p>
<p>首先，确定左边界:</p>
<p>newInterval肯定是取start,关键是原数据(后文中的A)中应该取start还是end。</p>
<p>如果与start比较，那么先猜想判断条件为A.start &gt;= newInterval.start。那么改变newInterval.start来试下条件是否依然成立。我们可以依次尝试4、3、2.5(这里取小数只是为了说明算法)。在这3种情况下，左边界都是在[3,5]。但是3个数与A.start分别是大于、等于、小于关系，并不能找出判断条件。</p>
<p>再试试end，猜想条件为A.end &gt;= newInterval.start。继续做上面的尝试，发现4、3、2.5情况下都满足，然后取2。这时[1.2]满足条件，左边界左移。所以猜想成立，左边界判断条件为A.end &gt;= newInterval.start。</p>
<p>接下来确定右边界：同理假设以后可得，应该取A.start。但是这里有个问题就是，我们找到的符合条件(A.start &gt; newInterval.end)是指向右边界的下一个。写代码时候需要注意。</p>
<p>找到2个迭代器后，如果2个在同一位置，说明插入数据没有和原数据重叠。其他情况下把左边界更新为新值，然后删除重叠的部分。</p>
<p>下面先给出寻找左边界的代码。由于原数据是有序的，所以我们自然而然想到二分。这里为了代码的整洁，<del>其实是我懒</del>，直接调用了STL里面的算法。STL中常用的二分有binary_search(), lower_bound(),upper_bound()。这里因为条件是 &gt;= 。所以用lower_bound。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> iti = lower_bound(intervals.begin(), intervals.end(), newInterval, [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.end &lt; b.start;&#125;);</div></pre></td></tr></table></figure>
<p>这里使用了<a href="https://msdn.microsoft.com/zh-cn/library/dd293608.aspx" target="_blank" rel="external"><em>lambda</em></a>表达式，其实如果这里写个单独的函数也是可以的，而且后文可以得到更加直观的结论。</p>
<p>然后是右边界的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> itj = upper_bound(iti, intervals.end(), newInterval, [](Interval a, Interval b) &#123;<span class="keyword">return</span> a.end &lt; b.start;&#125;);</div></pre></td></tr></table></figure>
<p>对比上面两段代码，我们发现：2个函数使用的谓词函数形式居然一样。等等，我们刚刚使用的不是A.end &gt;= newInterval.start与 A.start &gt; newInterval.end么？这里我第一次写的时候也出错了。<del>早知道自己写2个二分就没这么多事</del> 。查看STL源码后知道：upper_bound和lower_bound为了保持谓词的一致性(即 &lt;)，所以在lower_bound中二分法比较大小时调用的是<strong>Pred(*_Mid, Val)</strong>，而在upper_bound中调用的是<strong>!Pred(_Val, *_Mid)</strong>来完成比较操作。stl设计的巧妙可见一斑啊。不说了我继续去看stl源码了:)</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;Interval&gt; insert(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</div><div class="line">        <span class="keyword">auto</span> iti = lower_bound(intervals.begin(), intervals.end(), newInterval, [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.end &lt; b.start;&#125;);</div><div class="line">        <span class="keyword">auto</span> itj = upper_bound(iti, intervals.end(), newInterval, [](Interval a, Interval b) &#123;<span class="keyword">return</span> a.end &lt; b.start;&#125;);</div><div class="line">        <span class="keyword">if</span>(iti == itj)&#123;</div><div class="line">            intervals.insert(iti, newInterval);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            iti-&gt;start = min(iti-&gt;start, newInterval.start);</div><div class="line">            iti-&gt;end = max((itj - <span class="number">1</span>)-&gt;end, newInterval.end);</div><div class="line">            intervals.erase(iti + <span class="number">1</span>, itj);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> intervals;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>### </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题:&quot;&gt;&lt;/a&gt;问题:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;leetcode: Problem #57&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Insert Interval&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a set of &lt;em&gt;non-overlapping&lt;/em&gt; intervals, insert a new interval into the intervals (merge if necessary).&lt;/p&gt;
&lt;p&gt;You may assume that the intervals were initially sorted according to their start times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;Given intervals &lt;code&gt;[1,3],[6,9]&lt;/code&gt;, insert and merge &lt;code&gt;[2,5]&lt;/code&gt; in as &lt;code&gt;[1,5],[6,9]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;Given &lt;code&gt;[1,2],[3,5],[6,7],[8,10],[12,16]&lt;/code&gt;, insert and merge &lt;code&gt;[4,9]&lt;/code&gt; in as &lt;code&gt;[1,2],[3,10],[12,16]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is because the new interval &lt;code&gt;[4,9]&lt;/code&gt; overlaps with &lt;code&gt;[3,5],[6,7],[8,10]&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://ftdejo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://ftdejo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>c++4种转换</title>
    <link href="https://ftdejo.github.io/2018/01/21/c-4%E7%A7%8D%E8%BD%AC%E6%8D%A2/"/>
    <id>https://ftdejo.github.io/2018/01/21/c-4种转换/</id>
    <published>2018-01-21T03:12:57.000Z</published>
    <updated>2018-03-21T04:27:55.757Z</updated>
    
    <content type="html"><![CDATA[<p>c++相对于c，对于类型转换管理更加方便了，因为提供了4个操作符来管理显示的类型转换：</p>
<p>static_cast, dynamic_cast,const_cast, reinterpret_cast.</p>
<p>下面写写对4种转换的理解</p>
<a id="more"></a>
<p>1.const_cast: <strong>去掉</strong>const性质，唯一！也就是说，用其他的都不行。</p>
<p>2.static_cast 做强迫隐式转换，其实static_cast和其他的转换也有重合，主要是具体的行为不一样。</p>
<p>static_cast也可以转指针，只是他不会去读取RTTI的资料来验证而已，他会假设你已经有把握了。</p>
<p>3.dynamic_cast 动态识别指针或引用指向的对象： （安全向下转型）</p>
<p>涉及到运行时类型检查。如果绑定到引用或指针实际指向的对象不是目标类型，转换失败。返回0（指针），或抛出bad_cast异常（引用）。</p>
<p>4.reinterpret_cast  位操作转换（依赖编译器行为）一般需要精细控制内存部局的时候就会用到</p>
<p>  reinterpret_cast很难控制，但不是不能控制。这东西的应用说白了就是void*，有两种使用情景，一是要实现自定义的高性能数据结构的时候使用，二是底层IO。用的时候要注意封装好它产生的值的作用域，不要让不正常的类型的引用四处乱窜。</p>
<p>下面用一段代码来验证(运行环境x86 直接用的IDE VS2017编译器MSVC)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"f1\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"f2\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A, <span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">B* pb = <span class="keyword">new</span> B();</div><div class="line">C* pc = <span class="keyword">static_cast</span>&lt;C*&gt;(pb);</div><div class="line">C* pc_1 = <span class="keyword">reinterpret_cast</span>&lt;C*&gt;(pb);</div><div class="line">C* pc3 = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pb);</div></pre></td></tr></table></figure>
<p>首先根据dynamic_cast的定义，pc3肯定为0 ··</p>
<p>关键就是pc_1和pc转出来的指针区别</p>
<p>下面给出一次运行结果:</p>
<p>pc:0066F4D4, pc_1:0066F4D8</p>
<p>注意到pc_1的地址偏移了吗？</p>
<p>也就是说reinterpret_cast的转换由于比较底层，他不会去验证pb，直接一个强行的地址转换，就让pc_1指向原来pb指向的地址了。而static_cast就比较有意思了，他会自己把指针偏移，这样让转出来的指针看起来和一般指针一样(但此时指向的C对象中的A对象并没有初始化)</p>
<p>下面附个图吧。</p>
<p><img src="pic1.png" alt=""></p>
<p>所以接下来这段代码也就不难理解了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pc-&gt;f1();<span class="comment">//报错</span></div><div class="line">pc-&gt;f2();<span class="comment">//输出f2</span></div><div class="line">pc_1-&gt;f1();<span class="comment">//输出f2</span></div><div class="line">pc_1-&gt;f2();<span class="comment">//报错</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c++相对于c，对于类型转换管理更加方便了，因为提供了4个操作符来管理显示的类型转换：&lt;/p&gt;
&lt;p&gt;static_cast, dynamic_cast,const_cast, reinterpret_cast.&lt;/p&gt;
&lt;p&gt;下面写写对4种转换的理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://ftdejo.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] Search in Rotated Sorted Array搜索旋转排序数组</title>
    <link href="https://ftdejo.github.io/2017/12/21/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://ftdejo.github.io/2017/12/21/搜索旋转排序数组/</id>
    <published>2017-12-21T02:29:15.000Z</published>
    <updated>2018-01-25T09:41:21.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><blockquote>
<p>leetcode: Problem #33</p>
<p><strong>Search in Rotated Sorted Array</strong></p>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<a id="more"></a>
<p>题目大意就是把一组排序数组从头开始的一段数(可能是0,1..)移到数组最后，然后再进行查找。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h3><p>读题：整个数组还是”有序”的</p>
<p>猜想：用二分查找 应该可以O(logN)时间内完成。</p>
<p>关键是怎么在每次比较以后，确定上下限的位置，和平时的二分法是有区别的。</p>
<p><del>下面是回顾普通二分法时间，不想看的可以直接往下拉</del></p>
<p>首先，普通的二分法是这样的：</p>
<p>确定p（数组最小），q（数组最大），mid（数组中间位置）</p>
<p><img src="figure_1.png" alt="普通二分"></p>
<p>(真实情况不是连续函数，这里只是为了说明算法)</p>
<p>当p 在 q左边时，进行循环:</p>
<p>当我们要查找一个数(target)的时候，比较target与array[mid]，有3种可能性：</p>
<ol>
<li><p><span id="jumpl"></span>target &lt; array[mid]</p>
<p>目标值小于中值，所以我们要将整个查找范围<strong>左移</strong>，然后继续循环，即：</p>
<p><img src="figure_2.png" alt="左移"></p>
</li>
<li><p><span id="jumpr"></span>target &gt; array[mid]</p>
<p>目标值大于中值，<strong>右移</strong>，然后继续循环，即：</p>
<p><img src="figure_3.png" alt="右移"></p>
</li>
<li><p>target = array[mid]</p>
<p>找到目标值，退出循环</p>
</li>
</ol>
<p>循环如果结束，代表未找到，返回-1。</p>
<p>而在这道题中，数组不一定”完全”有序,也就是除了普通情况（此时数组未移动） 会再出现两种情况。</p>
<ul>
<li><p>case 1:</p>
<p> mid的右边数组为递增，而左边数组不再是单调递增。</p>
<p><img src="figure_4.png" alt="case 1"></p>
<p>​</p>
</li>
</ul>
<ul>
<li><p>case 2:</p>
<p>mid的左边数组为递增，而右边数组不再是单调递增。</p>
<p><img src="figure_5.png" alt="case 2"></p>
</li>
<li><p>case N:普通情况，即正常数组，此处不再复述。</p>
</li>
</ul>
<p>可以看出，比mid小的数，不一定在mid左边(case 1)，比mid大的数，不一定在mid右边(case 2))。但是，由于mid的两边，总有一边会保持单调性，所以只需判断是哪种情况，再进行我们的<a href="#jumpl">左移</a>或者<a href="#jumpr">右移</a>操作就可以继续循环了。</p>
<h3 id="解"><a href="#解" class="headerlink" title="解:"></a>解:</h3><p>前面步骤与普通二分法相同，关键在于判断target 与 array[mid]时，如果:</p>
<ol>
<li><p>target &lt; array[mid]</p>
<p>直觉告诉我们应该是左移，那么就找出满足什么条件时，target在mid左边。</p>
<p>case N: target 一定在mid左边。</p>
<p>case 1: 我们发现target也一定在mid左边，此时与case N相同。</p>
<p>即mid右边单调递增(array[mid] &lt;= array[q])时，target一定在mid左边；</p>
<p>case 2: target要想在mid左边，必须满足(target &gt;= array[p])，反之亦然。其实可以看出(target &gt;= array[p] )依然包括了case N。</p>
<p>其余情况，target在mid右边。</p>
</li>
<li><p>target &gt; array[mid]</p>
<p>找出右移的条件：</p>
<p>如果是case N || case 2,即mid左边单调递增(array[mid] &gt;= array[p])，target 一定在mid右边。</p>
<p>如果是case 1，target要想在mid右边，必须满足(target &lt;= array[q])，反之亦然。</p>
<p>其余情况，target在mid右边。</p>
</li>
<li><p>target = array[mid]</p>
</li>
</ol>
<p>​        找到目标值，循环结束。</p>
<p>循环如果结束，代表未找到，返回-1。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int search(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">	if(nums.empty())</div><div class="line">        return -1;</div><div class="line">    int p(0),q(nums.size() - 1);</div><div class="line">    while(p &lt;= q)&#123;</div><div class="line">        int mid = (p + q) / 2;</div><div class="line">        if(target &lt; nums[mid])&#123;</div><div class="line">            if(nums[mid] &lt;= nums[q] || target &gt;= nums[p])</div><div class="line">                q = mid - 1;</div><div class="line">            else</div><div class="line">                p = mid + 1;</div><div class="line">        &#125;   </div><div class="line">        else if(target &gt; nums[mid])&#123;</div><div class="line">            if(nums[mid] &gt;= nums[p] || target &lt;= nums[q])</div><div class="line">                p = mid + 1;</div><div class="line">            else</div><div class="line">                q = mid - 1;</div><div class="line">        &#125;</div><div class="line">        else </div><div class="line">            return mid;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题:&quot;&gt;&lt;/a&gt;问题:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;leetcode: Problem #33&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Search in Rotated Sorted Array&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., &lt;code&gt;0 1 2 4 5 6 7&lt;/code&gt; might become &lt;code&gt;4 5 6 7 0 1 2&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://ftdejo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://ftdejo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>c++函数模板与static</title>
    <link href="https://ftdejo.github.io/2017/11/21/c-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8Estatic/"/>
    <id>https://ftdejo.github.io/2017/11/21/c-函数模板与static/</id>
    <published>2017-11-21T02:52:17.000Z</published>
    <updated>2018-03-21T04:28:06.402Z</updated>
    
    <content type="html"><![CDATA[<p>一些个人理解</p>
<a id="more"></a>
<p>首先，明确static关键字的用处：</p>
<blockquote>
<p>对于特定类类型的全体成员而言，访问一个全局对象有时是必要的。也许，在程序的任意点需要统计已创建的特定类类型的数量；或者，全局对象可能是指向类的错误处理例程的一个指针；或者，他是指向类类型对象的内存自由储存区的一个指针。            </p>
<p>然而，全局对象会破坏封装：对象需要支持特定类抽象的实现。如果对象是全局的，一般的用户代码就可以修改这个值。</p>
<p>通常，非static数据成员存在于类类型的每个对象中。static数据成员独立于该类的任意对象而存在；每个static数据成员是与类关连的对象，并不与该类的对象关联。                           </p>
<p>  《c++ primer》节选</p>
</blockquote>
<p>通俗来说，static解决的问题就好比“共享单车”，放在那里，大家都可以骑。非static成员则是每个人自己的车，放在自己家里，别人一般时候骑不到。</p>
<p>而函数模板解决了什么呢？</p>
<blockquote>
<p>在泛型编程中，我们所编写的类和函数能够动态地用于跨越编译时不相关的类型。一个类火一个函数可以用来操纵多种类型的对象。</p>
<p>模板是泛型编程的基础，编译器可以用它产生多种特定类型的实例。我们只需编写一次模板，编译器将为使用模板的不同类型实例化模板。</p>
</blockquote>
<p>再举个例子（可能不是很恰当）：以后会实现一种标准，通过这种标准制造出来的东西，不管什么汽车、摩托车、自行车···只要考一个驾照，你就可以全都会开了。下面是我随手写的一个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Vehicle&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> license;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>声明非常简单，但是在c++中要注意定义问题：</p>
<p>首先来看static：<u>必须在类定义的外部定义并且进行初始化。(const例外)</u></p>
<p>然后模板的定义：抛开分别编译模型不谈(c++11已经抛弃了它··）。也就是说，<u>我们的编译器(包含编译模型)必须看到用到的所有模板的定义。</u>至于怎么看到呢，图方便的话，直接把模板的实现和声明都写在.h中就可以直接搞定。(<del>也可以用#include .cpp写法</del>)</p>
<p>所以如果是static+模板碰到一起的时候，具体的实现就变成了这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Vehicle&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> license;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vehicle&lt;T&gt;::license(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>怎么样，厉害吧？但是函数模板也没有那么神奇，我们也不可能每次都写出针对所有可能被实例化的类型最适合的模板。这个时候特化就派上例子了。</p>
<p>还是说刚刚的例子，明显一个驾照在现实生活是行不通的，于是我们要采用特化的方式去定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Vehicle&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> license;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vehicle&lt;T&gt;::license(<span class="number">0</span>);</div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">int</span> Vechicle&lt;Car&gt;::license(<span class="number">1</span>);</div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">int</span> Vechicle&lt;MotorCycle&gt;::license(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>现在，所有的Car都有了驾照1，所有的MotorCycle有了驾照2。其他的模板的实例化只有一个驾照0。</p>
<p>再说点什么，模板的本质和宏差不多，就是一系统预定义，不能把它和普通的源文件混淆，所以理所应当的，把他写在头文件里就行了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些个人理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://ftdejo.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>leetcode edit distance</title>
    <link href="https://ftdejo.github.io/2017/06/21/leetcode-edit-distance/"/>
    <id>https://ftdejo.github.io/2017/06/21/leetcode-edit-distance/</id>
    <published>2017-06-21T02:40:45.000Z</published>
    <updated>2018-03-21T02:46:24.215Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
</blockquote>
<a id="more"></a>
<p>先读题，给定word1和word2，求将word1转化为word2需要的”步数”。其中每一步可以是 增、减、替换中的一个操作。</p>
<p>这道题我开始想到的是LCS(最大公共子序列)的思路。即求出LCS，然后再分情况求出step。后来写lcs的时候发现，这道题本身用一个dp思路就可以解决。其实leetcode上挺多hard的题都是写一个dp就解决的··并不hard··</p>
<p>解法和LCS的解法非常相像：</p>
<p>用一个<code>dp[i+1][j+1]</code>二维数组来代表转换所需的步数。</p>
<p>首先看边界情况，<code>dp[i][0]</code>与<code>dp[0][j]</code>代表的意义是将一个字符串转换为长度为0(即空串)或者将空串转换为一个字符串。前者需要i次删除，后者需要j次插入。所以：<code>dp[i][0] = i</code> <code>dp[0][j] = j</code></p>
<p>然后再考虑通项：</p>
<p>要求<code>dp[i][j]</code>即要将字符串<code>word1[0..i - 1]</code>转换为<code>word2[0..j - 1]</code>，如果<code>word[i-1]</code>与<code>word2[j-1]</code>相等，那么所需的步数与将字符串<code>word1[0..i - 2]</code>转换为<code>word2[0..j - 2]</code>相同，即<code>dp[i][j] = dp[i - 1][j - 1]</code></p>
<p>当不相等的时候，我们可以有3种操作完成转换：</p>
<p>1.替换：将字符串<code>word1[0..i - 2]</code>转换为<code>word2[0..j - 2]</code>，然后把<code>word1[i - 1]</code>替换为<code>word2[j - 1]</code> 那么<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；</p>
<p>2.插入：将字符串<code>word1[0..i - 1]</code>转换为<code>word2[0..j - 2]</code> ，然后在<code>word2[0..j-2]</code>最后插入<code>word2[j - 1]</code>那么<code>dp[i][i] = dp[i][j - 1] + 1</code> ；</p>
<p>3.删除：把<code>word1[0..i-1]</code>最后一位删除，然后将字符串<code>word1[0..i - 2</code>转换为<code>word2[0..j - 1]</code> 那么<code>dp[i][i] = dp[i - 1][j] + 1</code> 。</p>
<p>通过自底而上生成来完成，返回<code>dp[n1][n2]</code>即为答案。</p>
<h2 id="Code1"><a href="#Code1" class="headerlink" title="Code1:"></a>Code1:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> n1 = word1.size(), n2 = word2.size();</div><div class="line">  <span class="keyword">int</span> tmp[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</div><div class="line">  tmp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n1 + <span class="number">1</span>; ++i) </div><div class="line">      tmp[i][<span class="number">0</span>] = i;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n2 + <span class="number">1</span>; ++j)</div><div class="line">      tmp[<span class="number">0</span>][j] = j;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n1 + <span class="number">1</span>; ++i)</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n2 + <span class="number">1</span>; ++j)&#123;</div><div class="line">          <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</div><div class="line">              tmp[i][j] = tmp[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">          &#125;<span class="keyword">else</span></div><div class="line">              tmp[i][j] = min(tmp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(tmp[i - <span class="number">1</span>][j], tmp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">  <span class="keyword">return</span> tmp[n1][n2];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后考虑优化，参照LCS的优化方法，整个<code>n1 * n2</code>的矩阵浪费了空间，因为每次计算只需要前三项，所以只需一个一维数组就行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Given two words &lt;em&gt;word1&lt;/em&gt; and &lt;em&gt;word2&lt;/em&gt;, find the minimum number of steps required to convert &lt;em&gt;word1&lt;/em&gt; to &lt;em&gt;word2&lt;/em&gt;. (each operation is counted as 1 step.)&lt;/p&gt;
&lt;p&gt;You have the following 3 operations permitted on a word:&lt;/p&gt;
&lt;p&gt;a) Insert a character&lt;br&gt;b) Delete a character&lt;br&gt;c) Replace a character&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://ftdejo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://ftdejo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>android异步消息机制</title>
    <link href="https://ftdejo.github.io/2017/04/26/android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://ftdejo.github.io/2017/04/26/android异步消息机制/</id>
    <published>2017-04-26T04:04:15.000Z</published>
    <updated>2017-05-03T08:32:00.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前一直被多线程和UI更新的问题所困扰，于是网上查阅以及翻看了相关源码，这篇文章用来记录异步消息机制，之后还会有一篇多线程相关的，恩，一定会有的。</p>
</blockquote>
<a id="more"></a>
<p>新手在写android的过程中，都可能遇到以下的错误:</p>
<p>android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</p>
<p>然后查阅了一番以后发现，哦，原来是子线程不能更新UI，然后用随便搜到的方法做解决（没错这个人就是我）</p>
<p>可是具体为什么能解决问题呢··这就是这篇文章要探讨的东西了。</p>
<h1 id="Handler-amp-Looper"><a href="#Handler-amp-Looper" class="headerlink" title="Handler&amp;Looper"></a>Handler&amp;Looper</h1><p>查看handler源码（基于androd-25，btw:AS中双击shift然后输入相关类即可查看源码，查看相关方法的快捷键是ctrl+o）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Default constructor associates this handler with the &#123;@link Looper&#125; for the</div><div class="line"> * current thread.</div><div class="line"> *</div><div class="line"> * If this thread does not have a looper, this handler won&apos;t be able to receive messages</div><div class="line"> * so an exception is thrown.</div><div class="line"> */</div><div class="line">public Handler() &#123;</div><div class="line">    this(null, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实源码注释已经说的非常清楚了，如果线程中没有looper对象，会抛出异常。这个错误什么时候会发生呢？我发现一个经常碰到的情况，就是当我们尝试在子线程中创建handler对象的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        Handler handler = new Handler();</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>运行这段代码，会抛出:java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p>
<p>正是源码中的异常，所以肯定这个时候是Looper对象为空所以报错咯。继续查看源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return the Looper object associated with the current thread.  Returns</div><div class="line"> * null if the calling thread is not associated with a Looper.</div><div class="line"> */</div><div class="line">public static @Nullable Looper myLooper() &#123;</div><div class="line">    return sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>myLooper方法是从sThreadLocal中取得相关的Looper。那么问题来了，这个Looper是何时被set的呢。再回头看错误信息，提示调用Looper.prepare()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/** Initialize the current thread as a looper.</div><div class="line"> * This gives you a chance to create handlers that then reference</div><div class="line"> * this looper, before actually starting the loop. Be sure to call</div><div class="line"> * &#123;@link #loop()&#125; after calling this method, and end it by calling</div><div class="line"> * &#123;@link #quit()&#125;.</div><div class="line"> */</div><div class="line">public static void prepare() &#123;</div><div class="line">    prepare(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    if (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">    mQueue = new MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没错，是在这里设置的Looper对象，而且这段代码告诉我们，一个线程中有且仅有一个Looper对象。并且源码还非常“体贴”的告诉我们得在调用prepare()以后调用loop()和quit()方法，具体是为什么我们后文再讲。</p>
<p>前面我们说到，如果线程中没有looper对象，会抛出异常，所以我用的代码是在子线程中创建Handler对象，但是如果我们直接在在主线程中创建Handler对象，是不会报错的，这是为什么呢？查看ActivityThread（即主线程）相关代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    Looper.prepareMainLooper();</div><div class="line"></div><div class="line">    ActivityThread thread = new ActivityThread();</div><div class="line">    thread.attach(false);</div><div class="line"></div><div class="line">    if (sMainThreadHandler == null) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (false) &#123;</div><div class="line">        Looper.myLooper().setMessageLogging(new</div><div class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // End of event ActivityThreadMain.</div><div class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">    Looper.loop();</div><div class="line"></div><div class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Initialize the current thread as a looper, marking it as an</div><div class="line"> * application&apos;s main looper. The main looper for your application</div><div class="line"> * is created by the Android environment, so you should never need</div><div class="line"> * to call this function yourself.  See also: &#123;@link #prepare()&#125;</div><div class="line"> */</div><div class="line">public static void prepareMainLooper() &#123;</div><div class="line">    prepare(false);</div><div class="line">    synchronized (Looper.class) &#123;</div><div class="line">        if (sMainLooper != null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，主线程中调用Looper.prepareMainLooper()方法，然后这个方法又会调用Looper.prepare()方法，所以主线程中自动存在一个Looper对象。</p>
<p>Looper与Hander的爱恨情仇实在是难以言尽，简单来说，<strong>在主线程中可以创建Handler对象，在子线程中创建Handler对象需要先调用Looper.prepare()方法。</strong></p>
<h1 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h1><p>Message即为消息，也就是异步消息处理过程中我们需要传递的信息，下面是一段利用Handler发送消息的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        Message message = new Message();</div><div class="line">        Bundle bundle = new Bundle();</div><div class="line">        bundle.putString(&quot;data&quot;, &quot;tempString&quot;);</div><div class="line">        message.setData(bundle);</div><div class="line">        handler.sendMessage(message);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>其中Message可以携带的信息并不止这一点，具体可以参考<a href="https://developer.android.google.cn/reference/android/os/Message.html" target="_blank" rel="external">这里</a>，但是这段方法中我们最关心的莫过于sendMessage()方法，查看Handler源码以后我们发现了一系列的发送方法，但其实以发送对象来分的话分为2种:</p>
<ul>
<li>一系列post()方法 主要是发送Runnable对象</li>
</ul>
<ul>
<li>一系列sendMessage()方法 主要是发送Message对象(包括sendEmptyMessage，这种方法的Massage对象只包含what值)</li>
</ul>
<p>这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public final boolean post(Runnable r)</div><div class="line">&#123;</div><div class="line">	// getPostMessage(r)将runnable封装成Message</div><div class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static Message getPostMessage(Runnable r) &#123;</div><div class="line">    Message m = Message.obtain(); //得到空的message</div><div class="line">    m.callback = r; //将runnable设为message的callback</div><div class="line">    return m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>产生一个Message对象，可以new，也可以使用Message.obtain()方法；两者都可以，但是更建议使用obtain方法，因为Message内部维护了一个Message池用于Message的复用，避免使用new 重新分配内存。</p>
</blockquote>
<p>然后最后调用到的是sendMessageAtTime()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    if (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说msg就是我们发出的Message，uptimeMillis为开机后的毫秒数（不包括深度睡眠时间）。这里创建了一个MessageQueue对象，这个是什么呢，故名思议消息队列（但其实他并不是一个队列，是一个链表）</p>
<p>继续查看Handler.enqueueMessage()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;//注意这一句设置msg.target为该handler！</div><div class="line">    if (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(true);</div><div class="line">    &#125;</div><div class="line">    return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就进入到了MessageQueue中的enqueueMessage方法去了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">    if (msg.target == null) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">    &#125;</div><div class="line">    if (msg.isInUse()) &#123;</div><div class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">        if (mQuitting) &#123;</div><div class="line">            IllegalStateException e = new IllegalStateException(</div><div class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        boolean needWake;</div><div class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">        	//将入队的msg置为链表头，并且唤醒堵塞队列</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 插入msg到链表中</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            for (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                if (p == null || when &lt; p.when) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; // invariant: p == prev.next</div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">        if (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，messageQueue其实就是通过时间排序的一个链表，每次有新的msg的时候通过代码中的方法插入到原消息队列中，然后我们就有了一个按时间排序的消息列表了。</p>
<p>入队操作我们已经知道了，那么有入必有出，我们就得找到出队操作了，之前在Looper.prepare()方法中我们有提到loop()和quit()方法，quit很好理解，退出Looper嘛，那么loop()方法是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;@link #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line">public static void loop() &#123;</div><div class="line">    final Looper me = myLooper();</div><div class="line">    if (me == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">    &#125;</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    final long ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        Message msg = queue.next(); // might block</div><div class="line">        if (msg == null) &#123;</div><div class="line">            // 没有消息，说明MQ正在退出</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final Printer logging = me.mLogging;</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                    msg.callback + &quot;: &quot; + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final long traceTag = me.mTraceTag;</div><div class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</div><div class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">        	//调用message.target的dispatchMessage方法</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (traceTag != 0) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这个方法中，用了一个死循环不断调用MQ的next()方法，这个方法就是我们要找的出队方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">Message next() &#123;</div><div class="line">    final long ptr = mPtr;</div><div class="line">    if (ptr == 0) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div class="line">    int nextPollTimeoutMillis = 0;</div><div class="line">    for (;;) &#123;</div><div class="line">        if (nextPollTimeoutMillis != 0) &#123;</div><div class="line">            Binder.flushPendingCommands();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            final long now = SystemClock.uptimeMillis();</div><div class="line">            Message prevMsg = null;</div><div class="line">            Message msg = mMessages;</div><div class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class="line">                do &#123;</div><div class="line">                    prevMsg = msg;</div><div class="line">                    msg = msg.next;</div><div class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">            &#125;</div><div class="line">            if (msg != null) &#123;</div><div class="line">                if (now &lt; msg.when) &#123;</div><div class="line">                	// 下一条消息还没准备好，设置间隔时间</div><div class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mBlocked = false;</div><div class="line">                    if (prevMsg != null) &#123;</div><div class="line">                        prevMsg.next = msg.next;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mMessages = msg.next;</div><div class="line">                    &#125;</div><div class="line">                    msg.next = null;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class="line">                    msg.markInUse();</div><div class="line">                    return msg;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                nextPollTimeoutMillis = -1;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (mQuitting) &#123;</div><div class="line">                dispose();</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">          	...</div><div class="line">        &#125;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法判断队列中message对象不为空就不断将下一条消息出列，否则阻塞，一直等到有新的消息入列。这个方法中拿到的msg对象到底拿去干嘛了呢？我们可以看到在loop()方法中调用了msg.target.dispatchMessage()方法，其中msg.target在前文Handler.enqueueMessage()方法中可以知道就是Handler，那么我们继续查看Handler.dispatchMessage()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        // 如果message设置了callback，即发送的是runnable消息，处理callback！</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">        	//如果handler本身设置了callback，则执行callback</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //否则直接调用Handler的handleMessage()方法</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 处理runnable消息</div><div class="line">private static void handleCallback(Message message) &#123;</div><div class="line">    message.callback.run();//直接调用run方法！</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 由子类实现</div><div class="line">public void handleMessage(Message msg) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Callback &#123;</div><div class="line">    public boolean handleMessage(Message msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过前文可知，如果使用handler的post方法创建一个Runnable对象发送的话，这个时候msg的callback不为null，执行callback回调，也就是我们的Runnable对象。然后如果在创建handler中有实现Handler.Callback接口，则执行。然后再执行重写的handlerMessage(msg)方法。</p>
<p>至此，基本源码的分析已经结束</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。</strong></li>
<li><strong>Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。</strong></li>
<li><strong>Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。</strong></li>
<li><strong>Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</strong></li>
<li><strong>在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。</strong></li>
</ol>
<p><img src="http://pic002.cnblogs.com/images/2011/315542/2011091323582123.png" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前一直被多线程和UI更新的问题所困扰，于是网上查阅以及翻看了相关源码，这篇文章用来记录异步消息机制，之后还会有一篇多线程相关的，恩，一定会有的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://ftdejo.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java intern()相关</title>
    <link href="https://ftdejo.github.io/2017/02/28/java-intern-%E7%9B%B8%E5%85%B3/"/>
    <id>https://ftdejo.github.io/2017/02/28/java-intern-相关/</id>
    <published>2017-02-28T08:21:28.000Z</published>
    <updated>2017-05-03T08:32:19.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>intern 这个方法返回的是返回字符串对象的规范化表示形式，当调用 intern 方法时，如果常量池已经包含一个等于此String 对象的字符串(该对象由equals(Object) 方法确定)，则返回池中的字符串。否则，将此String对象添加到池中，并且返回此 String 对象的引用。</p>
</blockquote>
<a id="more"></a>
<p><del>Talk is cheap show me the code</del></p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str1= &quot;aa&quot;;</div><div class="line">String str2 = new String(&quot;bb&quot;);</div><div class="line">System.out.println(&quot;******&quot;);</div><div class="line">System.out.println(str1.intern() == str1); //#1</div><div class="line">System.out.println(str2.intern() == str2); //#2</div></pre></td></tr></table></figure>
<blockquote>
<p>通过字面量赋值创建字符串时，会优先在常量池中查找是否已经存在相同的字符串，倘若已经存在，栈中的引用直接指向该字符串；倘若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。而通过new的方式创建字符串时，就直接在堆中生成一个字符串的对象。</p>
</blockquote>
<p>#1：因为str1指向的是常量池中的引用，调用intern()方法返回同一个引用，所以返回true。</p>
<p>#2：str2创建的字符串实例在java堆上，调用intern()方法必然不是同一个引用，所以返回false</p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">String baseStr = &quot;ccdd&quot;;</div><div class="line">final String baseFinalStr = &quot;ccdd&quot;;</div><div class="line"> </div><div class="line">String str1 = &quot;ccdd&quot;;</div><div class="line">String str2 = &quot;cc&quot;+&quot;dd&quot;;</div><div class="line">String str3 = baseStr + &quot;dd&quot;;</div><div class="line">String str4 = baseFinalStr+&quot;dd&quot;;</div><div class="line"> </div><div class="line">System.out.println(str1 == str2);//#3</div><div class="line">System.out.println(str1 == str3);//#4</div><div class="line">System.out.println(str1 == str4);//#5</div></pre></td></tr></table></figure>
<p>#3：常量字符串的”+”操作，编译阶段直接作为一个字符串处理，所以返回true</p>
<p>#4：字符串引用的”+”操作，其实是StringBuilder.append()操作，而由StringBuilder创建的字符串实例在Java堆上，所以返回false</p>
<p>#5：对于final修饰符，编译期直接进行了常量替换，而对于非final字段则是在运行期进行赋值处理的，所以str4相当于常量字符串，返回true</p>
<h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str1=new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString();</div><div class="line">String str2=new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</div><div class="line"></div><div class="line">System.out.println(str1.intern()==str1);  // #6</div><div class="line">System.out.println(str2.intern()==str2);  // #7</div></pre></td></tr></table></figure>
<p><strong>对于这段代码，在 JDK 1.6 和 JDK 1.7中的运行结果不同。<br>这段代码在JKD1.6中运行，会得到2个false。在JDK1.7中的运行结果却是true和false！</strong></p>
<blockquote>
<p>这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7后的intern方法在实现上发生了比较大的改变，JDK 1.7后(以及部分其他虚拟机，例如JRockit)，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中记录首次出现的实例引用。</p>
</blockquote>
<p>#6 常量池中没有”计算机软件”这个字符串，所以会在常量池中生成一个对堆中的”计算机软件”的引用，而在进行字面量赋值的时候，常量池中已经存在，所以直接返回该引用即可，因此str1和str2都指向堆中的字符串，返回true</p>
<p>#7 常量池中存在”java”字符串..至于为什么存在，不要在意这些细节..，所以str2.intern()会返回常量池中引用，返回false</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;intern 这个方法返回的是返回字符串对象的规范化表示形式，当调用 intern 方法时，如果常量池已经包含一个等于此String 对象的字符串(该对象由equals(Object) 方法确定)，则返回池中的字符串。否则，将此String对象添加到池中，并且返回此 String 对象的引用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://ftdejo.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
