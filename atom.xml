<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈六的博客</title>
  <subtitle>memo for code or game.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ftdejo.github.io/"/>
  <updated>2017-05-03T08:32:00.821Z</updated>
  <id>https://ftdejo.github.io/</id>
  
  <author>
    <name>陈六</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android异步消息机制</title>
    <link href="https://ftdejo.github.io/2017/04/26/android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://ftdejo.github.io/2017/04/26/android异步消息机制/</id>
    <published>2017-04-26T04:04:15.000Z</published>
    <updated>2017-05-03T08:32:00.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前一直被多线程和UI更新的问题所困扰，于是网上查阅以及翻看了相关源码，这篇文章用来记录异步消息机制，之后还会有一篇多线程相关的，恩，一定会有的。</p>
</blockquote>
<a id="more"></a>
<p>新手在写android的过程中，都可能遇到以下的错误:</p>
<p>android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</p>
<p>然后查阅了一番以后发现，哦，原来是子线程不能更新UI，然后用随便搜到的方法做解决（没错这个人就是我）</p>
<p>可是具体为什么能解决问题呢··这就是这篇文章要探讨的东西了。</p>
<h1 id="Handler-amp-Looper"><a href="#Handler-amp-Looper" class="headerlink" title="Handler&amp;Looper"></a>Handler&amp;Looper</h1><p>查看handler源码（基于androd-25，btw:AS中双击shift然后输入相关类即可查看源码，查看相关方法的快捷键是ctrl+o）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Default constructor associates this handler with the &#123;@link Looper&#125; for the</div><div class="line"> * current thread.</div><div class="line"> *</div><div class="line"> * If this thread does not have a looper, this handler won&apos;t be able to receive messages</div><div class="line"> * so an exception is thrown.</div><div class="line"> */</div><div class="line">public Handler() &#123;</div><div class="line">    this(null, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实源码注释已经说的非常清楚了，如果线程中没有looper对象，会抛出异常。这个错误什么时候会发生呢？我发现一个经常碰到的情况，就是当我们尝试在子线程中创建handler对象的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        Handler handler = new Handler();</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>运行这段代码，会抛出:java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p>
<p>正是源码中的异常，所以肯定这个时候是Looper对象为空所以报错咯。继续查看源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return the Looper object associated with the current thread.  Returns</div><div class="line"> * null if the calling thread is not associated with a Looper.</div><div class="line"> */</div><div class="line">public static @Nullable Looper myLooper() &#123;</div><div class="line">    return sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>myLooper方法是从sThreadLocal中取得相关的Looper。那么问题来了，这个Looper是何时被set的呢。再回头看错误信息，提示调用Looper.prepare()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/** Initialize the current thread as a looper.</div><div class="line"> * This gives you a chance to create handlers that then reference</div><div class="line"> * this looper, before actually starting the loop. Be sure to call</div><div class="line"> * &#123;@link #loop()&#125; after calling this method, and end it by calling</div><div class="line"> * &#123;@link #quit()&#125;.</div><div class="line"> */</div><div class="line">public static void prepare() &#123;</div><div class="line">    prepare(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    if (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">    mQueue = new MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没错，是在这里设置的Looper对象，而且这段代码告诉我们，一个线程中有且仅有一个Looper对象。并且源码还非常“体贴”的告诉我们得在调用prepare()以后调用loop()和quit()方法，具体是为什么我们后文再讲。</p>
<p>前面我们说到，如果线程中没有looper对象，会抛出异常，所以我用的代码是在子线程中创建Handler对象，但是如果我们直接在在主线程中创建Handler对象，是不会报错的，这是为什么呢？查看ActivityThread（即主线程）相关代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    Looper.prepareMainLooper();</div><div class="line"></div><div class="line">    ActivityThread thread = new ActivityThread();</div><div class="line">    thread.attach(false);</div><div class="line"></div><div class="line">    if (sMainThreadHandler == null) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (false) &#123;</div><div class="line">        Looper.myLooper().setMessageLogging(new</div><div class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // End of event ActivityThreadMain.</div><div class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">    Looper.loop();</div><div class="line"></div><div class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Initialize the current thread as a looper, marking it as an</div><div class="line"> * application&apos;s main looper. The main looper for your application</div><div class="line"> * is created by the Android environment, so you should never need</div><div class="line"> * to call this function yourself.  See also: &#123;@link #prepare()&#125;</div><div class="line"> */</div><div class="line">public static void prepareMainLooper() &#123;</div><div class="line">    prepare(false);</div><div class="line">    synchronized (Looper.class) &#123;</div><div class="line">        if (sMainLooper != null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，主线程中调用Looper.prepareMainLooper()方法，然后这个方法又会调用Looper.prepare()方法，所以主线程中自动存在一个Looper对象。</p>
<p>Looper与Hander的爱恨情仇实在是难以言尽，简单来说，<strong>在主线程中可以创建Handler对象，在子线程中创建Handler对象需要先调用Looper.prepare()方法。</strong></p>
<h1 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h1><p>Message即为消息，也就是异步消息处理过程中我们需要传递的信息，下面是一段利用Handler发送消息的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        Message message = new Message();</div><div class="line">        Bundle bundle = new Bundle();</div><div class="line">        bundle.putString(&quot;data&quot;, &quot;tempString&quot;);</div><div class="line">        message.setData(bundle);</div><div class="line">        handler.sendMessage(message);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>其中Message可以携带的信息并不止这一点，具体可以参考<a href="https://developer.android.google.cn/reference/android/os/Message.html" target="_blank" rel="external">这里</a>，但是这段方法中我们最关心的莫过于sendMessage()方法，查看Handler源码以后我们发现了一系列的发送方法，但其实以发送对象来分的话分为2种:</p>
<ul>
<li>一系列post()方法 主要是发送Runnable对象</li>
</ul>
<ul>
<li>一系列sendMessage()方法 主要是发送Message对象(包括sendEmptyMessage，这种方法的Massage对象只包含what值)</li>
</ul>
<p>这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public final boolean post(Runnable r)</div><div class="line">&#123;</div><div class="line">	// getPostMessage(r)将runnable封装成Message</div><div class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static Message getPostMessage(Runnable r) &#123;</div><div class="line">    Message m = Message.obtain(); //得到空的message</div><div class="line">    m.callback = r; //将runnable设为message的callback</div><div class="line">    return m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>产生一个Message对象，可以new，也可以使用Message.obtain()方法；两者都可以，但是更建议使用obtain方法，因为Message内部维护了一个Message池用于Message的复用，避免使用new 重新分配内存。</p>
</blockquote>
<p>然后最后调用到的是sendMessageAtTime()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    if (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说msg就是我们发出的Message，uptimeMillis为开机后的毫秒数（不包括深度睡眠时间）。这里创建了一个MessageQueue对象，这个是什么呢，故名思议消息队列（但其实他并不是一个队列，是一个链表）</p>
<p>继续查看Handler.enqueueMessage()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;//注意这一句设置msg.target为该handler！</div><div class="line">    if (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(true);</div><div class="line">    &#125;</div><div class="line">    return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就进入到了MessageQueue中的enqueueMessage方法去了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">    if (msg.target == null) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">    &#125;</div><div class="line">    if (msg.isInUse()) &#123;</div><div class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">        if (mQuitting) &#123;</div><div class="line">            IllegalStateException e = new IllegalStateException(</div><div class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        boolean needWake;</div><div class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">        	//将入队的msg置为链表头，并且唤醒堵塞队列</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 插入msg到链表中</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            for (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                if (p == null || when &lt; p.when) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; // invariant: p == prev.next</div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">        if (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，messageQueue其实就是通过时间排序的一个链表，每次有新的msg的时候通过代码中的方法插入到原消息队列中，然后我们就有了一个按时间排序的消息列表了。</p>
<p>入队操作我们已经知道了，那么有入必有出，我们就得找到出队操作了，之前在Looper.prepare()方法中我们有提到loop()和quit()方法，quit很好理解，退出Looper嘛，那么loop()方法是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;@link #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line">public static void loop() &#123;</div><div class="line">    final Looper me = myLooper();</div><div class="line">    if (me == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">    &#125;</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    final long ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        Message msg = queue.next(); // might block</div><div class="line">        if (msg == null) &#123;</div><div class="line">            // 没有消息，说明MQ正在退出</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final Printer logging = me.mLogging;</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                    msg.callback + &quot;: &quot; + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final long traceTag = me.mTraceTag;</div><div class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</div><div class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">        	//调用message.target的dispatchMessage方法</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (traceTag != 0) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这个方法中，用了一个死循环不断调用MQ的next()方法，这个方法就是我们要找的出队方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">Message next() &#123;</div><div class="line">    final long ptr = mPtr;</div><div class="line">    if (ptr == 0) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div class="line">    int nextPollTimeoutMillis = 0;</div><div class="line">    for (;;) &#123;</div><div class="line">        if (nextPollTimeoutMillis != 0) &#123;</div><div class="line">            Binder.flushPendingCommands();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            final long now = SystemClock.uptimeMillis();</div><div class="line">            Message prevMsg = null;</div><div class="line">            Message msg = mMessages;</div><div class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class="line">                do &#123;</div><div class="line">                    prevMsg = msg;</div><div class="line">                    msg = msg.next;</div><div class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">            &#125;</div><div class="line">            if (msg != null) &#123;</div><div class="line">                if (now &lt; msg.when) &#123;</div><div class="line">                	// 下一条消息还没准备好，设置间隔时间</div><div class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mBlocked = false;</div><div class="line">                    if (prevMsg != null) &#123;</div><div class="line">                        prevMsg.next = msg.next;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mMessages = msg.next;</div><div class="line">                    &#125;</div><div class="line">                    msg.next = null;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class="line">                    msg.markInUse();</div><div class="line">                    return msg;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                nextPollTimeoutMillis = -1;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (mQuitting) &#123;</div><div class="line">                dispose();</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">          	...</div><div class="line">        &#125;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法判断队列中message对象不为空就不断将下一条消息出列，否则阻塞，一直等到有新的消息入列。这个方法中拿到的msg对象到底拿去干嘛了呢？我们可以看到在loop()方法中调用了msg.target.dispatchMessage()方法，其中msg.target在前文Handler.enqueueMessage()方法中可以知道就是Handler，那么我们继续查看Handler.dispatchMessage()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        // 如果message设置了callback，即发送的是runnable消息，处理callback！</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">        	//如果handler本身设置了callback，则执行callback</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //否则直接调用Handler的handleMessage()方法</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 处理runnable消息</div><div class="line">private static void handleCallback(Message message) &#123;</div><div class="line">    message.callback.run();//直接调用run方法！</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 由子类实现</div><div class="line">public void handleMessage(Message msg) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Callback &#123;</div><div class="line">    public boolean handleMessage(Message msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过前文可知，如果使用handler的post方法创建一个Runnable对象发送的话，这个时候msg的callback不为null，执行callback回调，也就是我们的Runnable对象。然后如果在创建handler中有实现Handler.Callback接口，则执行。然后再执行重写的handlerMessage(msg)方法。</p>
<p>至此，基本源码的分析已经结束</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。</strong></li>
<li><strong>Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。</strong></li>
<li><strong>Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。</strong></li>
<li><strong>Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</strong></li>
<li><strong>在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。</strong></li>
</ol>
<p><img src="http://pic002.cnblogs.com/images/2011/315542/2011091323582123.png" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前一直被多线程和UI更新的问题所困扰，于是网上查阅以及翻看了相关源码，这篇文章用来记录异步消息机制，之后还会有一篇多线程相关的，恩，一定会有的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://ftdejo.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java intern()相关</title>
    <link href="https://ftdejo.github.io/2017/02/28/java-intern-%E7%9B%B8%E5%85%B3/"/>
    <id>https://ftdejo.github.io/2017/02/28/java-intern-相关/</id>
    <published>2017-02-28T08:21:28.000Z</published>
    <updated>2017-05-03T08:32:19.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>intern 这个方法返回的是返回字符串对象的规范化表示形式，当调用 intern 方法时，如果常量池已经包含一个等于此String 对象的字符串(该对象由equals(Object) 方法确定)，则返回池中的字符串。否则，将此String对象添加到池中，并且返回此 String 对象的引用。</p>
</blockquote>
<a id="more"></a>
<p><del>Talk is cheap show me the code</del></p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str1= &quot;aa&quot;;</div><div class="line">String str2 = new String(&quot;bb&quot;);</div><div class="line">System.out.println(&quot;******&quot;);</div><div class="line">System.out.println(str1.intern() == str1); //#1</div><div class="line">System.out.println(str2.intern() == str2); //#2</div></pre></td></tr></table></figure>
<blockquote>
<p>通过字面量赋值创建字符串时，会优先在常量池中查找是否已经存在相同的字符串，倘若已经存在，栈中的引用直接指向该字符串；倘若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。而通过new的方式创建字符串时，就直接在堆中生成一个字符串的对象。</p>
</blockquote>
<p>#1：因为str1指向的是常量池中的引用，调用intern()方法返回同一个引用，所以返回true。</p>
<p>#2：str2创建的字符串实例在java堆上，调用intern()方法必然不是同一个引用，所以返回false</p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">String baseStr = &quot;ccdd&quot;;</div><div class="line">final String baseFinalStr = &quot;ccdd&quot;;</div><div class="line"> </div><div class="line">String str1 = &quot;ccdd&quot;;</div><div class="line">String str2 = &quot;cc&quot;+&quot;dd&quot;;</div><div class="line">String str3 = baseStr + &quot;dd&quot;;</div><div class="line">String str4 = baseFinalStr+&quot;dd&quot;;</div><div class="line"> </div><div class="line">System.out.println(str1 == str2);//#3</div><div class="line">System.out.println(str1 == str3);//#4</div><div class="line">System.out.println(str1 == str4);//#5</div></pre></td></tr></table></figure>
<p>#3：常量字符串的”+”操作，编译阶段直接作为一个字符串处理，所以返回true</p>
<p>#4：字符串引用的”+”操作，其实是StringBuilder.append()操作，而由StringBuilder创建的字符串实例在Java堆上，所以返回false</p>
<p>#5：对于final修饰符，编译期直接进行了常量替换，而对于非final字段则是在运行期进行赋值处理的，所以str4相当于常量字符串，返回true</p>
<h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str1=new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString();</div><div class="line">String str2=new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</div><div class="line"></div><div class="line">System.out.println(str1.intern()==str1);  // #6</div><div class="line">System.out.println(str2.intern()==str2);  // #7</div></pre></td></tr></table></figure>
<p><strong>对于这段代码，在 JDK 1.6 和 JDK 1.7中的运行结果不同。<br>这段代码在JKD1.6中运行，会得到2个false。在JDK1.7中的运行结果却是true和false！</strong></p>
<blockquote>
<p>这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7后的intern方法在实现上发生了比较大的改变，JDK 1.7后(以及部分其他虚拟机，例如JRockit)，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中记录首次出现的实例引用。</p>
</blockquote>
<p>#6 常量池中没有”计算机软件”这个字符串，所以会在常量池中生成一个对堆中的”计算机软件”的引用，而在进行字面量赋值的时候，常量池中已经存在，所以直接返回该引用即可，因此str1和str2都指向堆中的字符串，返回true</p>
<p>#7 常量池中存在”java”字符串..至于为什么存在，不要在意这些细节..，所以str2.intern()会返回常量池中引用，返回false</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;intern 这个方法返回的是返回字符串对象的规范化表示形式，当调用 intern 方法时，如果常量池已经包含一个等于此String 对象的字符串(该对象由equals(Object) 方法确定)，则返回池中的字符串。否则，将此String对象添加到池中，并且返回此 String 对象的引用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://ftdejo.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
